# CSRF (Cross-site request forgery)

Cross-site request forgery (also known as CSRF) is a web security vulnerability that allows an attacker to induce users to perform actions that they do not intend to perform. It allows an attacker to partly circumvent the same origin policy, which is designed to prevent different websites from interfering with each other.

### Table of content

- [How does it work ?](#how-does-it-work)
- [Get method](#get-method)
- [Post method](#post-method)
- [bypass CSRF token validation](#bypassing-csrf-token-validation)
    - [Validation of CSRF token depends on request method](#validation-of-csrf-token-depends-on-request-method)
    - [Validation of CSRF token depends on token being present](#validation-of-csrf-token-depends-on-token-being-present)
    - [CSRF token is not tied to the user session](#csrf-token-is-not-tied-to-the-user-session)
    - [CSRF token is tied to a non-session cookie](#csrf-token-is-tied-to-a-non-session-cookie)
    - [CSRF token is simply duplicated in a cookie](#csrf-token-is-simply-duplicated-in-a-cookie)
- [Bypassing SameSite cookie restrictions]
    - [What is a site]
    - [Site vs origin]
    - [How does SameSite work?]

## How does it work ? 

Imagine that you've just opened a fraudulent link. A normal image could be `<img src="https://normal/img/dog">`, and the web browser would resolve the link and display the image.

Now, imagine that the image link is: `<img src="http://www.shopping-online.com/Index?buy=tv&nb=100&confirm=1">`.

In fact, thanks to CSRF, the hacker will attempt to use the connection cookies stored on your computer to make you perform unwanted actions behind your back. Here, they are trying to make you buy 100 TVs on the website http://www.shopping-online.com.

## Get Method

Get Method are easier to resolve and more predectible.

```html
<img src="http://www.shopping-online.com/Index?buy=tv&nb=100&confirm=1">
```

or:

```html
<script>
    location = "http://www.shopping-online.com/Index?buy=tv&nb=100&confirm=1";
</script>
```

## Post Method

```html
<html>
    <body>
        <form action="https://vulnerable-website.com/email/change" method="POST">
            <input type="hidden" name="email" value="pwned@evil-user.net" />
        </form>
        <script>
            document.forms[0].submit();
        </script>
    </body>
</html>
```

## Bypassing CSRF token validation

A CSRF token is a unique, secret, and unpredictable value that is generated by the server-side application and shared with the client. When issuing a request to perform a sensitive action, such as submitting a form, the client must include the correct CSRF token. Otherwise, the server will refuse to perform the requested action.

ex:

```html
<form name="change-email-form" action="/my-account/change-email" method="POST">
    <label>Email</label>
    <input required type="email" name="email" value="example@normal-website.com">
    <input required type="hidden" name="csrf" value="50FaWgdOhi9M9wyna8taR1k3ODOR8d6u">
    <button class='button' type='submit'> Update email </button>
</form>
```

### Validation of CSRF token depends on request method

Some applications correctly validate the token when the request uses the POST method but skip the validation when the GET method is used.

If the form use post method to transmit values, try give them with the GET method.

### Validation of CSRF token depends on token being present

Some applications correctly validate the token when it is present but skip the validation if the token is omitted.

### CSRF token is not tied to the user session

Some applications do not validate that the token belongs to the same session as the user who is making the request. Instead, the application maintains a global pool of tokens that it has issued and accepts any token that appears in this pool.

You can connect yourself and try your token to feed the victim's token.

### CSRF token is tied to a non-session cookie

In a variation on the preceding vulnerability, some applications do tie the CSRF token to a cookie, but not to the same cookie that is used to track sessions. This can easily occur when an application employs two different frameworks, one for session handling and one for CSRF protection, which are not integrated together:

```html
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF; csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv

csrf=RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY&email=wiener@normal-user.com
```

If the web site contains any behavior that allows an attacker to set a cookie in a victim's browser, then an attack is possible.

### CSRF token is simply duplicated in a cookie

In a further variation on the preceding vulnerability, some applications do not maintain any server-side record of tokens that have been issued, but instead duplicate each token within a cookie and a request parameter. When the subsequent request is validated, the application simply verifies that the token submitted in the request parameter matches the value submitted in the cookie. This is sometimes called the "double submit" defense against CSRF, and is advocated because it is simple to implement and avoids the need for any server-side state:

```
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa

csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&email=wiener@normal-user.com
```

In this situation, the attacker can again perform a CSRF attack if the web site contains any cookie setting functionality. Here, the attacker doesn't need to obtain a valid token of their own. They simply invent a token (perhaps in the required format, if that is being checked), leverage the cookie-setting behavior to place their cookie into the victim's browser, and feed their token to the victim in their CSRF attack.

---

## Bypassing SameSite cookie restrictions

SameSite is a browser security mechanism that determines when a website's cookies are included in requests originating from other websites. SameSite cookie restrictions provide partial protection against a variety of cross-site attacks, including CSRF, cross-site leaks, and some CORS exploits.

### What is a site: 

In the context of SameSite cookie restrictions, a site is defined as the top-level domain (TLD), usually something like .com or .net, plus one additional level of the domain name. This is often referred to as the TLD+1.

![site-def](/web/img/site-definition.png)

### Site vs origin

The difference between a site and an origin is their scope; a site encompasses multiple domain names, whereas an origin only includes one. Although they're closely related, it's important not to use the terms interchangeably as conflating the two can have serious security implications.

![site-vs-origin](/web/img/site-vs-origin.png)

Example

Request from | Request to | Same-site? | Same-origin?
--- | --- | --- | ---
https://example.com | https://example.com | Yes | Yes
https://app.example.com | https://intranet.example.com | yes | No: mismatched domain name
https://example.com | https://example.com:8080 | Yes | No: mismatched port
https://example.com | https://example.co.uk | No: mismatched eTLD | No: mismatched domain name
https://example.com | http://example.com | 	No: mismatched scheme | No: mismatched scheme

### How does SameSite work?

SameSite is an attribute of HTTP cookies that controls how cookies are included in requests sent to the server. It is primarily used to enhance security by minimizing the risks of Cross-Site Request Forgery (CSRF) and session theft.

All major browsers currently support the following SameSite restriction levels:

- Strict: Cookies are only sent if the origin (the host of the website) of the request exactly matches the origin of the web page that set the cookie. This means cookies are not shared across websites, even if user actions lead them from one site to another.
    - [Bypassing SameSite Strict restrictions using on-site gadgets](/web/bypass-Samesite-strict.md)
- Lax : Cookies are sent with top-level navigation requests (like clicking on a link or manually entering the URL) but not with requests for embedded resources (such as images, scripts, styles, etc.). This ensures that cookies are included in major requests that could result in a state change (e.g., form submission) but not in resource requests.
- None : Cookies are always sent, even for cross-origin requests. This means cookies are shared across websites. However, this mode also requires the cookie to have the Secure attribute (i.e., it must be transmitted via HTTPS rather than HTTP) for security reasons.

Here's an example of using the SameSite attribute:

```http
Set-Cookie: session=abcdef; SameSite=Strict; Secure
```

In this example, the session cookie will only be sent with requests from the same origin site (same domain). Additionally, it will only be sent over secure connections (HTTPS).

:warning: If the website issuing the cookie doesn't explicitly set a SameSite attribute, Chrome automatically applies Lax restrictions by default.

[**:arrow_right_hook: Back home**](/README.md)
